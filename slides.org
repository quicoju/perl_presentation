#+TITLE:     Quick Perl Intro
#+AUTHOR:    Francisco Jurado
#+EMAIL:     francisco.jurado@gmail.com
#+DATE:      2017-06-08 Thu
#+DESCRIPTION: Quick introduction of the Perl programming language
#+KEYWORDS: Perl, programming
#+LANGUAGE:  en
#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME:
#+startup: beamer
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [bigger]
#+BEAMER_FRAME_LEVEL: 2
#+BEAMER_THEME: Rochester [height=20pt]
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
#+latex_header: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Topic}\tableofcontents[currentsection]\end{frame}}

* Philosophy
** Motivation
#+ATTR_BEAMER: :overlay<-+>
   - Pragmatic
     + It will mold itself to do what you mean.
     + Because only you know what you need.
     + Won't enforce programming paradigm
     + Perl is a language for getting your job done
   - Motto
     + "There's more that one way to do it" *TIMTOWTDI* (Tim Toady)
     + "Easy things should be easy and hard things should be possible"
   - Larry Wall designed syntax based on the following principles
     + Things that are different, should look different
     + Common constructions should be short
     + Important information should come first
   - The three virtues of a programmer
     1. Laziness
     2. Impatience
     3. Hubris
** Baby Perl
#+ATTR_BEAMER: :overlay<-+>
  - Analogy when a person starts learning a new spoken language
  - You start by learning a few words, then start building simple sentences
  - Continue with simple conversations
  - Don't need to know a whole language to express ideas and concepts
  - Keep practicing and become a native speaker

* First steps
** perldoc
#+ATTR_BEAMER: :overlay<-+>
  - Documentation written in POD (sometimes embedded to source code)
  - Command line tool to view Perl documentation (language, modules, etc)
  - Example:
#+name: perldoc_example
#+begin_src sh :results output :exports both
$ perldoc perl
$ perldoc -l List::Util
$ perldoc -m List::Util
$ perldoc -f map
$ perldoc -v '$/'
#+end_src

** Built-in Data Structures (sigils)
   - Scalars variables use ($)
   - Array variables use (@)
   - Hash variables use (%)
   - They allow to separate variables into different namespaces: $name, @name, %name
** Context
*** Amount Context (void, scalar, list)
    - Governs how many items you expect from an operation 
#+name: amount_context
#+begin_src perl :results output :exports both
   - build_sales_report()                          # void context
   - my $earnings  = build_earnings_report()       # scalar context
   - my @details   = build_earnings_report()       # list context
   - my ($report)  = build_earnings_report()       # list context
   - process_report( build_earnings_report() )     # list context
   - save_amount( scalar build_earnings_report() ) # scalar context
#+end_src

*** Type Context (string, numeric, boolean)
    - Defines who Perl interprets a piece of data
    - In numeric context strings that don't look like numbers evaluate to 0
    - *Watch out!!*
#+begin_src perl :results output :exports both
   my $name = 'Francisco'
   say 'Really the same person?' if $name  == 'Frank';  # == imposes numeric context
   say 'Really the same person?'  if $name eq 'Frank';  # eq imposes string context
#+end_src

** Perl pronouns
*** The default scalar variable $_ (topic variable)
#+ATTR_BEAMER: :overlay<-+>
   - Most notable in its absence, many builtin operations work on this variable
   - Equivalent to the pronoun /it/
#+begin_src perl :results output :exports both
    <$fh>       # read line from file handle in $fh and stores the line in $_
    print(uc)   # prints the contents of $_ to stdout in upper case
#+end_src
   - Multiple built-ins operate on this variable: uc, say, print, lc, length, Perl Regex.
   - Looping directives default to $_ as the iteration variable
#+begin_src perl
  say "#$_" for 1 .. 10;
  while (<STDIN>)
  {
     chomp;
     say scalar reverse;
  }
#+end_src

*** The default Array variable @_, @ARGV
#+ATTR_BEAMER: :overlay<-+>
    - @_ is equivalent to the pronoun /they/ and /them/.
    - @ARGV contains the command line arguments to the program.
    - shift and pop operate on these to variable by default.
    - When operating on an empty filehandle, each element of @ARGV
      will be treated as a file name to open for reading.

* The community
** CPAN The Comprehensive Perl Archive Network 
#+ATTR_BEAMER: :overlay<-+>
    - http://www.cpan.org
    - http://www.metacpan.org
    - Tens of thousands of reusable packages
    - All kinds of problem solvers

** Perl Sites
#+ATTR_BEAMER: :overlay<-+>
   - Perl's homepage http://www.perl.org
   - Perl Monks http://perlmonks.org (25 years)
   - Perl blogs http://blogs.perl.org
   - Perl Weekly http://perlweekly.com
   - Perl Buzz   http://perlbuzz.com
** IRC and Events
   - Yet Another Perl Conference http://yapc.org
   - Server: irc://irc.perl.org
   - Channels: #perl-help #perl-qa #perl (also in Freenode)

* The Perl Language
** Names
#+ATTR_BEAMER: :overlay<-+>
    - Used for naming everything: functions, variables, packages, etc.
    - Valid names begin in `_' or a letter
    - Followed by any combination of letters, numbers and underscores
    - invalid names `invalid name', `3rdStrike', `~rare', `lisp-like-name'
** Variables (sigils again)
   - The sigil governs how to manipulate the data of a variable
   - The ($) will access a single element of an array or hash: $hash{ $key }, $array[ $index ] as accessor or as lvalue
** Namespaces
    - Namespace is a collection of symbols grouped under a globally unique name
    - Multi-level namespaces are allowed by joining names with (::) like in Modern::Perl
    - Within the namespace the only symbol name can be used
    - Outside the namespace use the fully qualified name
    - The default namespace is main

** Values
*** Strings
    - Piece of textual or binary data with no particular formatting, delimited by single or double quotes.
    - For escaping use backslash (\).
    - To use escaped sequence of meta-characters do it under double quotes "\t \n \b".
    - Concatenate stings with the concatenation operator (.)
    - use qq{} as an altenative to (") to prevent escaping repeatedly (\")
    - use q{}  as an alternative to (') to prevent escaping repeatedly (\')
    - Here docs are available
#+begin_src perl
   my $single_quoted_str = 'To be or not to be.';
   my $double_quoted_str = "Interpolate a variable: $name.\n"

   say $single_quoted_str . $double_quoted_str;

   # see perlop for good examples
   # ============================
   my $here_doc_str =<<"END_STRING"
   This is a list where variables can be interpolated for example
   the variable \$number has a value of $number
END_STRING
#+end_src

*** Numbers 
    - Support integers and floating-point values, can be any popular notation
#+begin_src perl
  my $integer = 5;
  my $float = 0.01;
  my $sci_float = 1.02e10;
  my $binary = 0b1101;
  my $octal = 012;
  my $hex = 0x12;
#+end_src
    - Support of "_" as number separator: 1_000_000_000
    - Perl treats everything that looks like a number as a number in numeric context

*** Undef
    - Represents an unassigned, undefined and unknown value
    - To set a variable to an undefined value: $var = undef;
    - To test for a defined value: defined $var;

*** Lists
    - `()' Denote a list, in scalar context evaluates to undef
    - `()' in list context it's an empty list and in lvalue imposes list context
    - my $count = () = get_list_of_colors();
    - The comma operator ',' creates a list, and it has very low precedence
    - The range operator also creates lists '..'
#+begin_src perl
    my @numbers  = (1, 2, 3, 4, 5);
    my @numbers2 =  1 .. 5;
    my @farm   = qw!horse chicken goat pig cow!
    my ($package, $filename, $line) = caller();
#+end_src

** Scalars
#+ATTR_BEAMER: :overlay<->
   - Fundamental data type: single, discrete value. String, number, fh, etc.
   - Identified by the ($) sigil
   - Any value type can be [re]assigned arbitrarily
   - Contains a numeric slot and a string slot
   - Subject to string interpolation
** Arrays
#+ATTR_BEAMER: :overlay<->
   - Arrays are used to store a collection of scalars
   - Access by index starting on 0
   - Use the scalar sigil to access an individual element
   - They grow or shrink as you manipulate them
   - Use each to iterate over the array
   - Slices an be used access multiple elements at the same time
   - In list context, arrays flatten into lists
   - Array interpolate into strings as the stringification of each element separated by /$"/
#+begin_src perl
   my @zero_to_nine = 0 .. 9;

   # Single element access
   $zero_to_nine[5];

   # select the last element 
   $zero_to_nine[ $#zero_to_nine ]
   $zero_to_nine[ @zero_to_nine-1 ]
   $zero_to_nine[-1]

   # Arrays in different contexts

   # scalar assignment
   $count = @zero_to_nine; 
   
   #scalar string concatenation
   say 'I got ' . @zero_to_nine . ' numbers'; 

   #string interpolation
   say "These are my @zero_to_nine numbers";

  #boolean context
  say 'I do have numbers.' if @zero_to_nine;

  # Slice
  my @selected_data = @data[ @indexes ];

  # indexes in splices is evaluated in list context
  @data[ @indexes ] = ($init_value) x @indexes;
#+end_src
*** Array Operations (destructive) (See examples)
    - push: Add to the end 
    - pop: Pull from the end
    - unshift: Push to the front
    - shift: Pull from the front
    - splice: remove, replaces elements from an array
#+begin_src perl
  # Merge multiple arrays in one push
  push my @pets, @dogs, @cats, @brids;
#+end_src
** Hashes
#+ATTR_BEAMER: :overlay<->
   - Also known as tables, associative arrays, dictionaries, etc
   - This structure has no order, don't rely on this.
   - Declare with the (%) sigil
   - Access a single element with ($) and "{}"
   - Test key existence with *exists*
   - Use *keys %hash* to extract a list containing the %key values
   - Use *values %hash* to extract a list containing the %hash valeus
   - Iterate over a hash with *each %hash*, it'll return a key/value pair and undef when done
   - To reset the iterator use either *keys* or *values*
   - Slices work just like in arrays but using braces *@hash{ @keys }*
   - To initialize a hash: *my %initialized_hash = map { $_ => 1 } @keys*
#+begin_src perl
   # initialize a hash
   my %music_genere_for = ( 'the beatles' => "rock", rush => "progressive" );

   # access a single element
   say $music_genere_for{'the beatles'};

#+end_src
*** Hash idioms
#+begin_src perl
   # To merge two hashes, use slices
   # you can rely in the order returned by keys and values
   @hash_1{ keys %hash_2 } = values %hash_2;

   # extract uniq values in an array
   my %uniq;

   undef @uniq{ @items }
   my @unique_items = keys %uniq;
#+end_src
** Scope
*** Lexical
    - Lexical scope governed by the syntax of the program usually within ({ and }) or entire files
    - Declared with *my*
    - They are visible in the declaration scope and in any scopes nested within it
    - Not visible in sibiling scopes
*** Our
    - Creates a local alias to a package variable and still enforces lexical scoping of the alias
#+begin_src perl
    package Fun::Package {
      our $fun_our = "howdy our!";
      say $fun_our;
    
      package Fun::Package::Nested {
        say "This is nested fun $fun_our";
      }
    };
    
    package Another::Package {
      say "Another::Package $Fun::Package::fun_our"
    }
    
    package main;
    say "From main: ", $Fun::Package::fun_our;
#+end_src

*** Dynamic
    - Also applies to visibility but instead of looking on compile time scopes, lookup through the calls stack
    - Dynamic scope applies only to global and package global variables
    - While a package global variable may be visible within all scopes, its value may change depending on *local*-ization
#+begin_src perl
    our $scope;
    
    sub inner {
        say $scope;
    }
    
    sub main {
        say $scope;
        local $scope = 'main() scope';
        middle();
    }
    
    sub middle {
        say $scope;
        inner();
    }
    
    $scope = 'outer scope';
    main();
    say $scope;
#+end_src
*** State
    - *state* Declares a lexical variable which has a one time initialization
** Control Flow    
*** if, unless and ternary conditional
    - The condition is evaluated in boolean context
#+begin_src perl
   # prefix form
   if ($true_val)  {
       say "This is true";
   }

   unless ($true_val) {
       say "This is false"; 
   }

   # postfix form
   say "This is true" if ($true_val);
   say "This is false" unless ($true_val);

   # Ternary conditional operator
   my $time_postfix = after_noot($time) ? 'PM' : 'AM';
#+end_src
*** for loops
    - The for loop aliases the iterator variable to the values in the iteration
#+begin_src perl
    # Prefix notation
    foreach(1 .. 10) {
      say "$_ * $_ = ", $_ * $_;
    }

    # Postfix notation
    say "$_ * $_ = ", $_ * $_ for 1 .. 10;

    # named lexical iterator
    foreach my $num (1 .. 10) {
      say "$num * $num = ", $num * $num;
    }

    # C style
    for (my $i = 0; $i <= 10; $i++) {
       say "$i * $i = ", $i * $i;
    }
#+end_src

*** While and Until
#+begin_src perl
   # shifting in the control block
   while (@values) { 
     say( shift @values );
   }

   # shift in the condition
   while (my $value = shift @values) {
     say $value;
   }

   until ($finished) {
      $finished = finished_yet();
   }

   # iterate over an open filehandle
   # this construct is equivalent to while (defined($_ = <$fh>)) {}
   while (<$fh>) {
       chomp and say;
   }

   # loop control
   while (<$fh>) {
     next if /\A#/;
     last if /\A__END__/;
   }

   # named loops and continue
   # SEE EXAMPLESo
   LINE:
   while (<$fh>) {
       chomp;

       PREFIX
       for my $prefix (@prefixes) {
           next LINE unless $prefix;
       }
   }
   continue {
     say "Force the execution of this block ....";
   }
#+end_src

** Coercion Context
   - Boolean Coercion
   - String Coercion
   - Numeric Coercion
   - Reference Coercion (Autovivification)
   - Scalar::Util::dualvar to manipulate scalar variable coercion
** Packages
   - Encapsulation of named entities in a single namespace
   - *package* declares a  package and a namespace
   - Everything declared within a *package* block refer to symbols in that package's table
   - The scope of a package continues until the next *package* or until the end of the file
   - The default package is *main*
   - A package has a version and three implicit methods: *import*, *unimport*, *VERSION*
   - Perl has /open namespaces/, you can add definitions at anytime
#+begin_src perl
   # new way to version packages
   package Pinball:Wizard v123.45.6 { ... }

   # old way
   package Pinball::Wizard { our $VERSION = 123.45.6; ... } 
#+end_src
** References
   - I does what you expect for references
   - Use the reference operator (\) on a variable to extract its reference
   - References are scalar values
   - To dereference a reference use the corresponding sigil for the referenced variable
   - Another way to dereference use the arrow operator;
#+begin_src perl
    my $name = 'Larry';
    my $name_ref = \$name;

    # to modify the value from the reference
    $$name_ref = 'Moe';
#+end_src
*** Array references
    - To create a new unamed array reference use *[]*
#+begin_src perl
    my @names = qw(Larry Moe Curly);
    my $names_ref = \@names;

    # Access one element
    $$names_ref[0]  = 'Moe';
    $names_ref->[1] = 'Curly';

    # Access the entire array
    my $name_count = @$names_ref;

    # or slice
    my @last_two = @{ $names_ref }[-1, -2];

    # create an un-named refernece 
    my $pets_ref = [qw/cat dog bird/];
#+end_src
*** Hash references
    - To create a new unamed hash reference use *{}*
#+begin_src perl
    my %spanish_color_for = (
        blue   => 'azul',
        gold   => 'dorado',
        red    => 'rojo',
        yellow => 'amarillo',
    );

    # Extract reference, keys and vlues
    my $spanish_color_for_ref = \%spanish_color_for;
    my @spanish_colors = values %{ $spanish_color_for_ref };
    my @english_colors = keys   %{ $spanish_color_for_ref };

    # Access a single element
    my $cool_color = $spanish_color_for_ref->{'red'}
    my $same_cool_color = ${ $spanish_color_for_ref }{'red'}

    # slice
    my @colores = @{ $spanish_color_for_ref }{qw/red blue green/}

    # create an unnamed reference
    my $spanish_colors_ref = {
        blue   => 'azul',
        gold   => 'dorado',
        red    => 'rojo',
        yellow => 'amarillo',
    };   
#+end_src

*** Function references
    - Functions in perl are data types
    - To create an unamed function use *sub* without a name
    - To extract the reference of an existing named function use the *\* followed by the function sigil *&*
#+begin_src perl
    # Extract the reference
    sub bake_cake { say 'Baking a wonderful cake!' };
    my $cake_sub_ref = \%bake_cake;

    # Call the function from the reference
    $cake_sub_ref->();
    
    # or ...But this is old don't use it
    &$cake_sub_ref; 
#+end_src
*** Filehandle references
    - The lexical filehandle form of *open* and *opendir* operate on filehandles references
    - The references are object of *IO::File*

#+begin_src perl
    use autodie 'open';
    open my $out_fh, '>', 'output_file.txt';

    # write to the file handle
    $out_fh->say( 'Have some text!' );

    # ...or
    say $out_fh 'Have some text!'; 
#+end_src
*** Reference Count
    - Perl's memory management technique is reference count.
      1. Keeps track of the number of places where a reference is being used
      2. When the count drops to 0, perl knows that it's safe to claim the memory.

*** Cool stuff about references
    - Nested data structures
    - For  more information about Perl data structures use *perldoc perldsc* 
#+begin_src
    my %band_members_in = (
        'The Beatles' => {
            'John Lennon'     => [ qw/guitar voice keyboards/ ],
            'Paul McCartney'  => [ qw/bass voice guitar drums piano/ ],
            'George Harrison' => [ qw/guitar voice bass/ ],
            'Ringo Starr'     => [ qw/drums voice tambourine/ ],
        },
        'Minutemen' => {
            'D. Boon'         => [ qw/guitar voice/ ],
            'Mike Watt'       => [ qw/bass voice/ ],
            'George Hurley'   => [ qw/drums/ ],
        },
        'Cafe Tacuba' => {
            'Ruben Albarran'    => [ qw/voice/ ],
            'Emmanuel del Real' => [ qw/keyboards voice/ ],
            'Joselo Rangel'     => [ qw/guitar voice/ ],
            'Enrique Rangel'    => [ qw/bass/] 
        }
    )

   sub john_lennon_played {
       say join( q/, /, @{ $band_members_in{'The Beatles'}->{'John Lennon'} } );

       # ...or
       local $" = q/, /;
       say "@{ $band_members_in{'The Beatles'}->{'John Lennon'} }"
   }

  band_member_played(member => 'Mike Watt', band => 'Minutemen');

  sub band_member_played {
      my %params = @_;
      my ($band, $member) = @params{qw/band member/};

      if ( $band 
            && member
            && exists $band_members_in{$band}->{$member}
            && defined $band_members_in{$band}->{$member} ) {

          local $" = q/, /;
          say "@{ $band_members_in{'$band'}{'$member} }"

           # ...what happened to the -> between {$band} and {$member}?
      }
  }

  # to debug nested data structures you can *use Data::Dumper*
#+end_src
** Operators
   - Perl, an "operator-oritented language"?
   - Reference about operators *perldoc perlop* and *perldoc perlsyn*
   - Important concepts about operators:
     1. Precedence:    (1 + 5) * 6
     2. Associativity, whether left to right or right to left:  2 ** 3 ** 4
     3. Arity, number of operands on which the operator operates: unary, binary, trinary
     4. fixity, the position relative to its operands
	1. Infix: $length * $width
	2. Prefix and postfix: ++$x and $x++
	3. Circumfix: qw[one two three four]
	4. Postcircumfix: $hash{$x} *{} come after $hash and suround $x*
   - Operator types
     1. Numeric Operators: +, -, *, /, **, %, +=, --, etc
     2. String Operators:  =~, !~, eq, ne, gt, lt, ge, le, cmp
     3. Logical Operators: &&, and, ||, or, //, etc
     4. Bitwise Operators: >>, <<, &, |, ^
     5. Repetition operator: x
     6. Range operator: 1 .. 10, but in boolean context it's the flip flop operator
** Functions
*** Declaration
    - Use the *sub* builtin followed by a name and a code block
*** Invoking
    - When invoking a function use postcircumfix parentheses (optional most of the times)
    - Arguments can be arbitrary expressions
*** Parameters
    - A function receives its parameters in a single array *@_*
    - You need to unpack the arguments in *@_* for one parameter use *shift*
    - Starting on v5.20 signatures are now supported as "Experimental
    - If you operate directly on the contents of *@_* you're operating directly the calling values
#+begin_src perl
   use experimental 'signatures';
   
   sub greet($name = 'Juan') {
       say "Hello, $name";
   }
#+end_src

*** Facts
    - Every function has a containing namespace
    - A function can be contained in another namespace anywhere in the code
    - Lexical subs are available starting on v5.18 *perldoc perlsub*
#+begin_src perl
     sub Some::Package::my_function { ... }
#+end_src

*** Importing from other packages
    - When loading a module with *use* perl calls *import()* with any arguments passed to it
#+begin_src perl
    use strict 'refs';         
    use strict qw/subs vars/   

    # is equivalent to
    BEGIN {
        require strict;
        strict->import('refs');
        strict->import( qw/subs vars/ );
    }
#+end_src

*** call stack
    - *caller* inspect the calling context: *my ($package, $file, $line) = caller()*
    - *caller(n)* where n is the stack frame if n == 0, then stack from top
    - *Carp::croack* and *Carp::carp* to report from the caller's point of view
** Closures
#+begin_src perl
sub gen_fib {
        my @fibs = (0, 1);

        return sub {
            my $item = shift;

            if ($item >= @fibs) {
                for my $calc (@fibs .. $item) {
                    $fibs[$calc] = $fibs[$calc - 2]
                                 + $fibs[$calc - 1];
                }
            }
            return $fibs[$item];
        }
    }

    # calculate 42nd Fibonacci number
    my $fib = gen_fib();
    say $fib->( 42 );
#+end_src
** AUTOLOAD
   - This is the default function to call in a package when calling to an non-existing function
   - The arguments passed to the non-existing functions are passed to AUTOLOAD via @_
   - The package global $AUTOLOAD will contain the name of the non-existing function
   - The caller to the non-existing sub will get whatever AUTOLOAD returns
#+begin_src perl
    sub AUTOLOAD {
        our $AUTOLOAD; 
        say "Hello from AUTOLOAD: user tried to run $AUTOLOAD"

        # if want to register the non-existent name into the current package
        my $method = sub { ... };

        no strict 'refs';
        *{ $AUTLOAD } = $method;
        return $method->(@_);       # or return goto &$method;
    }

    non_existing( one => 'argument' );
#+end_src perl
* Regular Expressions
  - *m//* or the shorter  *//* identifies a regular expression
  - *=~* is the binding operator, when evaluated in scalar context a
    match evaluates to boolean value representing the success or
    failure of the match
  - *!~* is the negated version of the binding operator
  - *s////* 
#+begin_src perl
    my $mood = "Because I'm happy";
    say 'I found a happy in string' if $mood =~ /happy/;

    my $mood =~ s/happy/sad/;
    say $mood;
#+end_src
** qr// Operator
   - Creates first-class regexes that can be stored in variables
   - can be used to create complex regex patterns
#+begin_src perl
    my $happy = qr/happy/i;
    my $sad   = qr/sad/i;

    say "You're being emotional" if $mood =~ m{ $happy|$sad }
#+end_src

** Quantifiers
   - *?* Matches zero or more preceeding expressions
   - *+* Matches one or more
   - *\** Matches zero or more
   - *{m[,[n]]} Matches m but not more than n

** Metacharacters
   - *.* Match *any* character except a newline
   - *\w* represents all Unicode alphanumeric characters. Negated as: *\W* 
   - *\d* Matches a numeric character. Negated as *\D*
   - *\s* Matches whitespace characters (tab, space, CR, LF, newline). Negated as *\S*
   - *\Q\E* Disable metacharacter interpretation *m/\Q$literal_text\E/*

** Character Classes
   - *[]* Group alternatives as *[aeiou]* matches any of the vowels or *[A-Za-z0-9]* to match ranges
   - *[^]* To negate the atoms within the class like *[^aeiou]*

** Anchors
   - Fixes the position of a regex
   - *\A* start of string
   - *\Z* Match at the end of the string or before newline at the end of the string
   - *\z* end of string
   - *^* start of a line
   - *$* end of a line
   - *\b* boundary between a word character *\w* and a non-word character *\W*

** Assertions
   - Assertions are zero-width and don't consume characters from the match
   - *(?=)* Positive look-ahead assertion *$disastrous_feline = qr/cat(?=astrophe)/*
   - *(?!)* Negative look-ahead assertion *$safe_feline = qr/cat(?!astrophe)/*;
   - *(?<=)* Positive look-behind assertion *$space_cat = qr/(?<=\s)cat/*
   - *\K* variable positive look-behind assertion. *s/foo\Kbar//g* same as *s/(foo)bar/$1/g*

** Named Captures
   - Capture matches for later use using *(?<name>$regex)*
   - This will create a new entry in the *%+* hash with the key *name* and the matched text as the value
   - To remove capturing from parentheses use *(?:)*
#+begin_src perl
   my $contact_info = '(202) 456-1111';

   # build regex
   my $area_code = qr/\(\d{3}\)/;
   my $local_number = qr/\d{3}-?\d{4}/;
   my $phone_number = qr/$area_code\s?$local_number/;

   # match and capture
   if ($contact_info =~ /?<phone>$phone_number/) {
       say "You can call this guy at $+{ phone }"
   }

   # Also used in substitutions
   my $mood = "I'm feeling happy";
   $mood =~ s/feeling (?<mood>\w+)/not feeling $+{mood}/;
#+end_src

** Numbered Captures
   - On unamed captures, captures with parentheses with store the matches in variables $1, $2, ...
#+begin_src perl
    if ( $contact_info =~ /($phone_number)/ ) {
        say "You can call this guy at $1";
    }

    # also used in substitutions
    my $mood = "I'm feeling happy";
    $mood =~ s/feeling (\w+)/not feeling $1/;
#+end_src 

** Modifiers
   - Configure the behavior of the regular expression, they can be appear at the end of *m//* or *qr//*
   - Or they can appear within the expression
   - *i* Match ignoring case
   - *m* Allows the *^* and *$* anchors to match at any newline embedded within the string
   - *s* Treats the source string as a single line so *.* wll match the newline character
   - *r* Substitution operation returns the result of the substitution without modifying the source
   - *x* Allows the regexp to have embedded additional whitespace and comments
   - *g* matches a regex globally throughout a string
   - *e* allows to write arbitrary code on the right side of a substitution operation
#+begin_src perl
    my $re = qr/text/i
    $re = qr/(?i)text/

    # disable the modifiers by prepending a -
    $re = qr/(?-i)text/

    # using named captures
    $re = /(?<name>(?i)text/

    # multi-line regex
    my $attr_re = qr{
        \A                    # start of line

        (?:
          [;\n\s]*            # spaces and semicolons
          (?:/\*.*?\*/)?      # C comments
        )*

        ATTR

        \s+
        (   U?INTVAL
          | FLOATVAL
          | STRING\s+\*
        )
    }x;
#+end_src perl

* Objecs
** Vanilla OO
   - Perl's core object system is deliberately minimal
   - it only has three rules
     1. A class is a package
     2. A method is a function
     3. A (blessed) reference is an object
*** bless
    - Associates a reference to a class name
    - A blessed reference now is a validn invocant and Perl will
      perform method dispatch
    - A constructor is the method that creates a blessed reference
#+begin_src perl
  package Fish;
  use Carp;

  sub new {
    my ($class, %fish_attrs) = @_;

    croak "This fish needs a name"
      unless exists $fish_attrs{name};

    croak "This fish needs a diet"
      unless exists $fish_attrs{name};

    $fish_attrs{birth_year} = (localtime)[5] + 1900
      unless exists $fish_attrs{birth_year};

    bless \%fish_attrs, $class;
  }

  sub diet {
    my ($self, $diet) = @_;

    return $self->{diet}
      unless $diet;

    $self->{diet} = $diet;
  }

  sub name {
    return shift->{name};
  }

  sub age {
    return (localtime)[5] + 1900 - shift->{birth_year};
  }

  1;
#+end_src
*** Classes
    - They're just packages *package*
*** Methods
    - They're just functions *sub*
    - If want to override a parent method just declare the method in
      the child class using the same name, and call *SUPER::* to
      dispatch the parent
#+begin_src perl
  sub overriden {
    my $self = shift;
    return $self->SUPER::overriden(@_);
  }
#+end_src
*** Inheritance
    - Perl uses a package global variable *@ISA* to keep track of inheritance
    - The method dispatcher looks in each class's *@ISA* to find the names of its parents

#+begin_src perl
package InjuredPlayer {
  @InjuredPlayer::ISA = qw/Player Hospital::Patient/;
}

# Better yet use the parent pragma
package InjuredPlayer {
  use parent qw/Player Hospital::Patient/;
}
#+end_src

**** DOES()
**** AUTOLOAD()
**** SUPER()

** Moose
*** Classes
    - define classes by naming them with *package* and *use Moose* within the package
    - define a property with *has* *perldoc Moose::Manual::Attributes*
    - define a method with *sub*   *perldoc Moose::Manual*
#+begin_src perl
    package Car {
        use Moose;

        # Properties
        # =
        has painted_with => (       # paint goodies
            is      => 'ro',
            isa     => 'ArrayRef',
            default => sub { [qw/blue smurfs/] },
            lazy    => 1,
        );

        # Methods
        # =
        sub run {
          my $self = shift;
          $self->turn_on_engine();
          $self->fuel_engine()
        }
    }

    # Car class user
     use Car;
     my $flaming_car = Car->new( painted_with => [ qw/flames devils/ ]  );

     local $" = ' and ';
     say "This car was painted with @{ $flaming_car->painted_with }";

#+end_src 
*** Roles
    - Collection of behaviors and state
    - Can't instantiate a role
    - Declared with *Moose::Role*
    - *requires* lists the required methods for its composing clases
    - *with* composes the Role into a class
    - *DOES* will tell if the object "does" a role
#+begin_src perl
    package LivingBeing {
        use Moose::Role;

        requires qw/ name age diet /;
    }

    package CalculateAge::From::BirthYear {
        use Moose::Role;
        
        has 'birth_year',
            is => 'ro',
            isa => 'Int',
            default => sub { (localtime)[5] + 1900 };

        sub age {
            my $self = shift;
            my $year = (localtime)[5] + 1900

           return $year - $self->birth_year;
        }
    }

    package Cat {
        use Moose;
     
        has 'hame' => ( is => 'ro', isa => 'Str' );
        has 'diet' => ( is => 'rw', isa => 'Str' );

        with 'LivingBeing', 'CalculateAge::From::BirthYear';
    }

    my $kitty = Cat->new( 
        diet => 'fish', 
        birth_year => 2010,
        name => 'dude',
     );

    say $kitty->name, ' is alive!! ' 
        if $kitty->DOES('LivingBeing');

    say $kitty->name, ' is ', $kitty->age, ' years old.';
#+end_src

*** Inheritance
    - Use a inheritance when one class truly extends another
    - Use a role when a class needs additional behavior, espacially when that behavior has a meaningful name
    - Inherit from an existing class by using *extends*, it takes a list of parent classes
    - use *+* to indicate that an attribute is modifying the attribute
    - To override a method use *override*
    - *isa* will tell if the invocant extends a named class
#+begin_src perl
  package LightSource {
    use Moose;

    has 'candle_power',
      is      => 'ro',
      isa     => 'Int',
      default => 1;

    has 'enabled'
      is      => 'ro',
      isa     => 'Bool',
      default => 0,
      writer  => '_set_enabled';

    sub light {
      my $self = shift;
      $self->_set_enabled(1);
    }

    sub extinguish {
      my $self = shift;
      $self->_set_enabled(0);
    }
  };

  package SuperCandle {
    use Moose; extends 'LightSource';

    has '+candle_power', default => 100;
  }

  package LigthSource::Cranky {
    use Carp 'carp';
    use Moose;

    extends 'LigthSource';

    overide light => sub {
      my $self = shift;
      carp "Can't light a lit LightSource!" if $self->enabled;
      super();
    };

    override extinguish => sub {
      my $self = shift;
      carp "Can't extinguish unlit LightSource!" unless $self->enabled;
      super();
     };
  }
#+end_src
*** Metaprogramming and Reflection
    - Inspect a class via *meta*
#+begin_src perl
  my $meta = LightSource->meta;

  say 'LightSource instances have the attributes:';
  say $_->name for $meta->get_all_attributes;

  say 'LightSource instances support the methods:';
  say $_->fully_qualified_name for $meta->get_all_methods;
#+end_src
    - Once a module has been loaded, it's registered in *%INC*
    - *Class::Load* does the task of properly checking this
    - To check if a package exists ask *UNIVERSAL* *$pkg->can('can')*
    - To check the version of a module *$module->VERSION()*
    - To check if a function exists in a package *$pkg->can( $func )*
    - 

*** Moose::Manual
    - Look at the manual for tons of interesting features
** UNIVERSAL
   - The *UNIVERSAL* package is the ancestor of all other packages, the ultimate parent
   - provides the following methods
     1. VERSION() - Returns the value of the $VERSION package global
     2. DOES() - Supports the use of Roles in programs
     3. can() - Returns the function reference if it's supported
     4. isa() - Returns true if its invocant derives from the named class
* Misc
** Files
   - Perl offers a Unix style view of the filesystem. Use *File::Spec*
     to protably manipulate file paths
   - Another option for this task *Path::Class*
   - *-X* test operators
     + *-e* File exists
     + *-f* File is a plain file
     + *-d* File is a directory
     + *-r* File allows read
     + *-s* File is Non-empty
     + *perldoc -f -X* for more tests
** Idioms
   - We reviewed different idioms when looking at arrays and hashes.
*** Schwartzian Transform
   - The *Schwartzian Transform* list handling idiom borrowed from Lisp
#+begin_src perl
  # Associate the names of workers and phone extensions

  # Problem make a phone book, sorted by name;

  my %extensions = (
    '000' => 'Freddie',
    '002' => 'Brian',
    '042' => 'John',
    '044' => 'Roger',
   );

  # sort list by name alphabetically, need to sort by values
  my @sorted_names = sort values %extensions;

  # map/transform data to preserve key/value information
  my @pairs = map { [ $_, $extensions{$_} ] } keys %extensions;

  # sort data using new representation
  my @sorted_pairs = sort { $a->[1] cmp $b->[1] } @pairs;

  # format the sorted data
  my @formatted_exts = map { "$_->[1], ext. $_->[0]" } @sorted_pairs;

  # print data
  say for @formatted_exts;

  # Schwartzian Transform chain all the previous steps
  say for
    map  { "$_->[1], ext. $_->[0]" }
    sort { $a->[1] cmp $b->[1] }
    map  { [ $_ => $extensions{$_} ] }
    keys %extensions;
#+end_src
*** File Slurping
#+begin_src perl
  my $file = do { local $/; <$fh> };

  # ...or
  my $file; { local $/; $file = <$fh> };

  # .. or
  use File::Slurper; my $content = read_text($filename);)
#+end_src
** Exceptions
   - To throw an exception, use *die* or *croak*
   - To catch an exception, evaluate the code that can throw the
     exception withing an eval block, inspect the exception using *$@*
#+begin_src perl
  local $@;

  # catch the exception
  my $fh = eval { open_log_file('some_file.log'} };

  # analyze the exception
  if (my $exception = $@) {
   # re-throw the exception if we can't handle it here
   die $exception unless $exception =~ /^Can't open logging/;
   $fh = log_to_syslog();
  }
#+end_src
** Pragmas
   - Perl modules that influence the behavior of the language
   - By convension, pragma names are written in lower case
   - Using a pragma makes its behavior effective within a lexical scope
   - To disable pragmas, it can be done in a lexical scpoe as well with *no*
   - Some useful pragmas:
     1. strict   *Always use*
     2. warnings *Always use*
     3. utf8
     4. autodie
     5. constant
     6. vars
     7. feature *use 5.18* or *use feature ':5.18'*
     8. experimental
     9. less - Write your own lexical pragmas *perldoc perlpragma*
#+begin_src perl
use strict;
{
  no strict 'refs';
}
#+end_src
** Taint Mode
   - Sticky piece of metadata attached to all data which comes from the outside
   - Any data derived from tainted data is also tainted *perldoc perlsec*
   - Launch your program with the *-T* command line argument to enable tainted mode
   - *Scalar::Util::tainted()* returns true if its argument is tainted
   - To remove tain from data, extract known-good portions of the data
     with a regular expression capture
   - *-t* flag enables taiin mode but reduces tain violations from
     excemptions to warnings
#+begin_src perl
  die 'Number still tainted!' unless $number =~ /(\(/d{3}\) \d{3}-\d{4})/;
  my $safe_number = $1;
#+end_src
** One liners
** Fun
*** Acme namespace
*** JAPH / Obfuscated Perl Contest
**** The dromedary
* Testing
** Test::More
   - *ok()* The most basic assertion test function, takes two values
   - *is()* Compares two values using Perl's eq operator. Aplies scalar context/
   - *isnt()* Compares two values using ne
   - *cmp_ok()* You can provide the comparision operator
   - *isa_ok()* Tests if a reference is of any type
   - *can_ok()* Tests if an object provides functionality
   - *is_deeply()* Compares two references to ensure their contents are equal
#+begin_src perl
  Use Test::More tests => 1;  # Test plan
  ok  1, 'the number one is a true value';

  done_testing();
#+end_src 
** Test Anything Protocol
   - The output from the tests are formatted in /Test Anything Protocol (TAP)/
   - http://testanything.org
** Running Tests
   - The program *prove* runs tests, interprets TAP and display relevant information
   - See *perldoc prove* for more options 
** Organizing tests

   - CPAN distributions should include a *t/* directory containing test files *.t*
   - When building a distribution, the testing step runs all the tests
   - Two common organization of tests are used:
     1. Each *.t* file corresponds to a *.pm* file
     2. Each *.t* file corresponds to a logical feature
   - Hundered of testing modules available
* Modules
  - Package contained in its own file and loadable with *use* or *require*
  - A module must be valid perl codd
  - It must end with an expression that evaluates to true, so the
    parser knows that it has loaded successfully
  - When loading a module, Perl splits the pacakge name on (::) and
    turns the components of the package name into a file path.
  - The search is made in every directory in *@INC*
** Using and Importing
   - With *use* perl loads a module from disk and calls *import* with any arguments provided
   - The *no* builtin calls a module's *unimport* passing any arguments
   - The call to *import* and *unimport* happens during compilation
** Exporting
   - The module *Exporter* is the standard way to export symbols from a module
   - Relies on the presence of *@EXPORT_OK* and *@EXPORT*

#+begin_src perl
  package StrangeMonkey::Utilities;
  use Exporter 'import';

  # Will export these symbols upon request 
  our @EXPORT_OK = qw/round translate screech/;

  # Will export these symbols by defaul
  our @EXPORT = qw/dance sleep $variable/;

  # Then on client code ...
  use StrangeMonkey::Utilities qw/round sleep/;  # will import round and sleep
#+end_src

* Distributions
  - Collection of metadata and modules into a single, redistributable and installable unit
  - The easiest way to configure, build, package, test and install
    Perl code is to follow the CPAN's conventions
  - A distribution built on these standards can be tested on several
    versions of Perl on several different hardware platforms
** Attributes of a Distribution
#+ATTR_BEAMER: :overlay<-+>
  - *Build.PL* or *Makefile.PL* - Drives the configuration, build, test, bundle and install
  - *MANIFEST* - List of all files contained in the distribution
  - *META.yml* or *META.json* - Metadata about the distribution and dependencies
  - *README* - Description of the distribution, copyright and licensing information
  - *lib/* - Directory containing Perl modules
  - *t/* - Directory containing test files
  - *Changes* - Text Log of every significant change to the distribution

** CPAN Tools for managing distributions 
#+ATTR_BEAMER: :overlay<-+>
  - *CPANTS* http://cpants.perl.org evaluates each uploaded
    distribution against packaging guidelines
  - *CPAN.pm* officieal CPAN client
  - *ExtUtils::MakeMaker* Package, build, test and install Perl
    distributions works with *Makefile.PL*
  - *App::cpanminus* configuration-free CPAN client
  - *App::perlbrew* helps you to manage multiple installations of Perl.
  - *CPAN::Mini* Allows to create a private mirror of teh public CPAN
  - *Dist::Zilla* Automatest away common distribution tasks
  - *Carton and Pinto* Manage and install code's dependencies
  - *Module::Build* alternative for *ExtUtils::MakeMaker* written in pure Perl

* Good readings
** Camel book - http://shop.oreilly.com/product/9780596000271.do
** Modern Perl - http://modernperlbooks.com/books/modern_perl_2016/index.html
** Perl Best Practices - http://shop.oreilly.com/product/9780596001735.do
** Higher Order Perl - http://hop.perl.plover.com/
** Mastering Algorithms with Perl - http://shop.oreilly.com/product/9781565923980.do
* Projects
** Database
*** DBI - http://dbi.perl.org/
*** DBIx::Class - http://www.dbix-class.org/about.html
** Web programming
*** Plack - http://plackperl.org/
** Web frameworkds
*** Catalyst - http://www.catalystframework.org/
*** Dancer - http://perldancer.org/
*** Mojolicious - http://mojolicious.org/
** Data Science and Math
*** PDL - http://pdl.perl.org/
** Image Manipulation
*** Imager - https://metacpan.org/pod/Imager
** Life Science
*** BioPerl - http://bioperl.org/
** Object Oritentation Systems
*** http://moose.iinteractive.com/en/
* Interesting examples
** Perl special blocks 
#+begin_src perl
print               "    PRINT: main running\n";
die                 "    DIE:   main dying\n";
die                 "DIE XXX /* NOTREACHED */";
END         { print "1st END:   done running"    }
CHECK       { print "1st CHECK: done compiling"  }
INIT        { print "1st INIT:  started running" }
END         { print "2nd END:   done running"    }
BEGIN       { print "1st BEGIN: still compiling" }
INIT        { print "2nd INIT:  started running" }
BEGIN       { print "2nd BEGIN: still compiling" }
CHECK       { print "2nd CHECK: done compiling"  }
END         { print "3rd END:   done running"    }
#+end_src

* Beamer Examples
 This slide consists of some text with a number of bullet points:
 #+ATTR_BEAMER: :overlay <+->
 - the first, very *important*, point!
 - the previous point shows the use of the special markup which
   translates to the Beamer specific /alert/ command for highlighting
   text.

 The above list could be numbered or any other type of list and may
 include sub-lists.

** Control Flow

** A more complex slide
This slide illustrates the use of Beamer blocks.  The following text,
with its own headline, is displayed in a block:
*** Org mode increases productivity                               :B_theorem:
    :PROPERTIES:
    :BEAMER_env: theorem
    :END:
    - org mode means not having to remember LaTeX commands.
    - it is based on ascii text which is inherently portable.
    - Emacs!

    \hfill \(\qed\)

** Two columns
*** A block						      :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.4
    :END:
    - this slide consists of two columns
    - the first (left) column has no heading and consists of text
    - the second (right) column has an image and is enclosed in an
      *example* block

*** A screenshot                                            :BMCOL:B_example:
    :PROPERTIES:
    :BEAMER_col: 0.6
    :BEAMER_env: example
    :END:
    #+ATTR_LATEX: width=\textwidth
    [[file:///home/quicoju/doc/notes/perl_presentation/a-simple-slide.png]]

** Babel
   :PROPERTIES:
   :BEAMER_envargs: [t]
   :END:
*** Octave code						      :BMCOL:B_block:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:
#+name: octaveexample
#+begin_src octave :results output :exports both
A = [1 2 ; 3 4]
b = [1; 1];
x = A\b
#+end_src

*** The output						      :BMCOL:B_block:
    :PROPERTIES:
    :BEAMER_col: 0.4
    :BEAMER_env: block
    :BEAMER_envargs: <2->
    :END:
#+results: octaveexample
#+begin_example
A =

   1   2
   3   4

x =

  -1
   1
#+end_example
